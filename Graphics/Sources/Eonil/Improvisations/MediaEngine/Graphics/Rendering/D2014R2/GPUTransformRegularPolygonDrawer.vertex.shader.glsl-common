R"(


//#include	"Common.shader"		//	Will be included by C++ compiler.













//	Parameters.
PARAM	mat4	transformP;
PARAM	float	instancesP[(EEGLSL_MAX_VERTEX_UNIFORM_VECTOR_COUNT-16)*4];		//	One INST is 2 * 4D vectors (32 bytes). Just preserve all possible areas. This is defined as a float-array because OpenGL ES 2.0 GLSL 1.00 doesn't support writing array of struct values.


//	Inputs.
IN		float	angleV;
IN		float	indexV;

//	Outputs.
OUT		vec4	colorF;












struct
INST
{
	vec2	position;
	float	inner;
	float	outer;
	vec4	color;
};

INST
instance_at(int index)
{
	const int	INST_COMPS	=	2+1+1+4;
	
	INST	inst;
	inst.position.x	=	instancesP[index * INST_COMPS + 0];
	inst.position.y	=	instancesP[index * INST_COMPS + 1];
	inst.inner		=	instancesP[index * INST_COMPS + 2];
	inst.outer		=	instancesP[index * INST_COMPS + 3];
	inst.color.r	=	instancesP[index * INST_COMPS + 4];
	inst.color.g	=	instancesP[index * INST_COMPS + 5];
	inst.color.b	=	instancesP[index * INST_COMPS + 6];
	inst.color.a	=	instancesP[index * INST_COMPS + 7];
	return	inst;
}


/*!
 All vertexes must be pre-transformed (would be in CPU) before passing to this shader
 to be drawn batched. This will be updated to perform transform in GPU using SRT 
 information.
 */
void
main()
{
	int		idx1	=	int(indexV);
	INST	inst	=	instance_at(idx1);
	
	float	s1		=	sign(angleV);
	float	r1		=	s1 > 0.0 ? inst.outer : inst.inner;
	
//	float	scl_out	=	s1 * 0.5 + 0.5;
//	float	scl_in	=	s1 * 0.5 - 0.5;
//	float	r1		=	scl_in * inst.inner + scl_out * inst.outer;
	
//	float	r1		=	s1 > 0.0 ? 0.3 : 0.2;
	
	float	t1		=	abs(angleV) - 1.0;
	float	x		=	inst.position.x + (cos(t1) * r1);
	float	y		=	inst.position.y + (sin(t1) * r1);
	
	gl_Position		=	vec4(x, y, 0.0, 1.0) * transformP;		//	Output must be vec4.
	colorF			=	inst.color;
//	colorF			=	vec4(1.0, 1.0, 1.0, 1.0);
}















)" // +END